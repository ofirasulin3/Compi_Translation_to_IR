%{
#include <iostream>
#include <stdlib.h>
#include "utilities.h"
#include "hw3_output.hpp"
#include "SymbolTable.h"

#define YYSTYPE Node*


using namespace output;
using namespace std;
int yyerror(const char * message);

extern int yylineno;
extern char* yytext;
extern unsigned int yyleng;
extern int yylex();

SymbolTable * symbolTable = new SymbolTable();

%}


%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token TRUE
%token FALSE
%token RETURN
%nonassoc IF
%nonassoc ELSE
%token WHILE
%token BREAK
%token CONTINUE
%token SWITCH
%token CASE
%token DEFAULT
%token COLON
%token SC
%token COMMA
%token NUM
%token STRING
%token ID
%right ASSIGN
%left OR
%left AND
%left RELOPEQ
%nonassoc RELOPREL
%left BINOPPLUS
%left BINOPMUL
%left NOT
%left RPAREN
%left LPAREN
%token LBRACE
%token RBRACE

%%


Program : Funcs 																	{
																					//printf("\n Done!\n");

																					$$ = new Program();

																					};

Funcs :   																            {//printf("Funcs :   \n");
                                                                                    $$ = new Funcs();};
Funcs : FuncDecl Funcs  														    {//printf("Funcs : FuncDecl Funcs\n");
                                                                                    $$ = new Funcs();
                                                                                    };
FuncDecl : RetType ID LPAREN Formals RPAREN                                         {    RetType* tmp1 = (RetType*) $1;
                                                                                         Node * tmp2 = (Node*) $2;
                                                                                         Formals * tmp4 = (Formals*) $4;
                                                                                         //creating a new funcDeclaration object to insert into the funcs list
                                                                                         funcDeclaration * toInsert = new funcDeclaration(tmp2->info.c_str(), tmp4->FormalDeclarationsList.formalsListDec,tmp1->retType.c_str());
                                                                                         int duplicateIndex;

                                                                                         //checking if exists, and return "identifier already exists error"

                                                                                        for(int i = 0; i<tmp4->FormalDeclarationsList.formalsListDec.size(); i++)
                                                                                        {
                                                                                            string funcName = string(tmp2->info.c_str());
                                                                                            if(tmp4->FormalDeclarationsList.formalsListDec[i].name.compare(funcName)==0)
                                                                                            {
                                                                                                errorDef(yylineno, tmp4->FormalDeclarationsList.formalsListDec[i].name);
                                                                                                exit(0);
                                                                                            }

                                                                                            if(symbolTable->isFuncExistsByNameStr(tmp4->FormalDeclarationsList.formalsListDec[i].name))
                                                                                            {
                                                                                                errorDef(yylineno, tmp4->FormalDeclarationsList.formalsListDec[i].name);
                                                                                                exit(0);
                                                                                            }

                                                                                        }

                                                                                         if(symbolTable->isFuncExistsByName(*toInsert) )
                                                                                         {
                                                                                             errorDef(yylineno, toInsert->funcName);
                                                                                             exit(0);
                                                                                             //printf("%s %s %d \n", "Id is: ", toInsert->funcName, 83);
                                                                                         }
                                                                                         //checking if there 2 arguments with the same name
                                                                                         duplicateIndex = symbolTable->argDuplicateInFuncSig(*toInsert);

                                                                                        if(duplicateIndex!= -1)
                                                                                        {
                                                                                             errorDef(yylineno, toInsert->paramList[duplicateIndex].name);
                                                                                             exit(0);
                                                                                             //printf("%s %s %d \n", "Id is: ", toInsert->funcName, 135);
                                                                                        }
                                                                                         //after making sure the function wasnt declared before, add it to the funcs list
                                                                                         symbolTable->addFunc(*toInsert);

                                                                                         //after making sure the function wasnt declared before, add it to the scopes table
                                                                                         symbolTable->AddNewTable(tmp2->info.c_str());

                                                                                         //after making sure the function wasnt declared before, add it to the funcs list
                                                                                         for(int i = 0; i<toInsert->paramList.size(); i++)
                                                                                         {
                                                                                             Symbol arg = *(new Symbol(toInsert->paramList[i].name.c_str(), toInsert->paramList[i].type.c_str(), 0, true));
                                                                                             symbolTable->addNewArg(arg);
                                                                                         }
																						 funcHandler(tmp2->info.c_str(), tmp1->retType.c_str(), formalsVecToStringVec(tmp4->FormalDeclarationsList.formalsListDec));
                                                                                        }
LBRACE Statements RBRACE                                                            {
																					   RetType* tmp1 = (RetType*) $1;
                                                                                       symbolTable->pop();
																					   emitFuncRetType(tmp1->retType.c_str());
                                                                                    };
RetType : Type 																        {    Type * tmp1 = (Type*)$1;
																					    $$ = new RetType(tmp1->type.c_str());};

RetType : VOID 																        {//printf("RetType : VOID\n");
                                                                                        $$ = new RetType("VOID");};
Formals :  																            {//printf("Formals :\n");
                                                                                        $$ = new Formals();};
Formals : FormalsList 															    {//printf("Formals : FormalsList\n");
                                                                                        $$ = new Formals((FormalsList*)$1);};
FormalsList : FormalDecl       													    {//printf("FormalsList : FormalDecl\n");
                                                                                        $$ = new FormalsList((formalDeclaration*)$1);};
FormalsList : FormalDecl COMMA FormalsList 											{//printf("FormalsList : FormalDecl COMMA FormalsList \n");
                                                                                        $$ = new FormalsList((formalDeclaration*)$1, (FormalsList*)$3);};
FormalDecl : Type ID  																{//printf("FormalDecl : Type ID \n");
                                                                                        $$ = new formalDeclaration(((Type*)$1)->type.c_str(), ((Node*)$2)->info.c_str(), yylineno);};
Statements : Statement 															    
{//printf("Statements : Statement 	\n");
    $$ = new statements();
    statement * tmpStatement = (statement*)$1;
    long long size = tmpStatement->listCol->continue_list->size();
    bpList * continue_list = tmpStatement->listCol->continue_list;
    bpList * break_list = tmpStatement->listCol->break_list;
    bpList * next_list = tmpStatement->listCol->next_list;
    if(size > 0)
    {
       CodeBuffer::instance().bpatch( *next_list , CodeBuffer::instance().genLabel());

    }
    statements * tmp2 = (statements*)$$;
    tmp2->listCol->continue_list = continue_list;
    tmp2->listCol->break_list = break_list;
};
Statements : Statements Statement  													
{
$$ = new statements();
    statement * tmpStatement2 = (statement*)$2;
    long long size = tmpStatement2->listCol->continue_list->size();
    bpList * continue_list2 = (tmpStatement2->listCol->continue_list);
    bpList * break_list2 = tmpStatement2->listCol->break_list;
    bpList * next_list2 = tmpStatement2->listCol->next_list;

    $$ = new statements();
    statement * tmpStatement1 = (statement*)$1;

    bpList * continue_list1 = tmpStatement1->listCol->continue_list;
    bpList * break_list1 = tmpStatement1->listCol->break_list;
    bpList * next_list1 = tmpStatement1->listCol->next_list;

    if(size > 0)
    {
       CodeBuffer::instance().bpatch( *next_list2 , CodeBuffer::instance().genLabel());
    }

    statements *tmpS = (statements*) $$;

    *(tmpS->listCol->continue_list) = CodeBuffer::instance().merge(*continue_list1 ,*continue_list2);
};

Statement : LBRACE   												{
                                                                                    //printf("Statement : LBRACE Statements RBRACE\n");
                                                                                    symbolTable->AddNewTable("BLOCK");}
            Statements RBRACE                                                       {
																					//this is after rbrace
																					symbolTable->pop();
																					$$ = new statement();
																					};

Statement : Type ID SC  															{//printf("Statement : Type ID SC \n");
                                                                                     const char* id = ((Node*)$2)->info.c_str();
                                                                                     Type * type = (Type*)$1;

																					//Check if the a variable with the same ID was not declared on containing scope.

																					if(symbolTable->isVarExists(id) || symbolTable->isFuncExistsByNameStr(string(id)))
																					{
																					errorDef(yylineno,((Node*)$2)->info);
																					exit(0);
																					}
																					//Add to symbol table: Add this variable to the top table.
																					Symbol arg = *(new Symbol(id, type->type.c_str(), 0, false));
																					//create new arg object and insert to the *last* table on the symbol table.};
																					symbolTable->addNewArg(arg);
};

Statement : Type ID ASSIGN Exp SC
{
    //printf("Statement : Type ID ASSIGN Exp SC\n");
    Exp * expression = (Exp*)$4;
    Type * type = (Type*)$1;
    const char* id = ((Node*)$2)->info.c_str();
    //printf("1\n");
    const char* l_type = type->type.c_str();
    const char* r_type = expression->type.c_str();
    //printf("r_type is: %s \n" , r_type);

    Symbol arg = *(new Symbol(id, l_type, 0, false));

    //Check if ID already exists in containing block. If yes - ERROR.
    //Check if assign operator is legal. If no - ERROR.
    //Add Arg to symbol table.

    if(symbolTable->isVarExists(id) || symbolTable->isFuncExistsByNameStr(string(id)))
    {
        errorDef(yylineno,id);
        exit(0);
        //printf("%s %s %d \n", "Id is: ", id, 139);
    }
    //printf("2\n");

    if(!symbolTable->isAssignLegal(l_type,r_type))
    {
        //printf("Inside If\n");
        errorMismatch(yylineno);
        exit(0);
    }

    if(symbolTable->addNewArg(arg) == -1)
    {
    //report ERROR

        exit(0);
    }

    $$ = new statement();
    };

Statement : ID ASSIGN Exp SC
    {Exp * tmp = (Exp*)$3;

    const char* id = ((Node*)$1)->info.c_str();
    const char* r_type = tmp->type.c_str();

    //Check if Id exists on containing scope. If not - return ERROR.
    //Check if assign is legal. If not - return ERROR.
    if(!symbolTable->isVarExists(id))
    {
        errorUndef(yylineno,((Node*)$1)->info);
        exit(0);
    }

    const char* l_type = symbolTable->searchSymbolByName(id).Type.c_str();



    if(!symbolTable->isAssignLegal(l_type,r_type))
    {
        errorMismatch(yylineno);
    }

    $$ = new statement();};
Statement : Call SC 															    {$$ = new statement();};
Statement : RETURN SC    												    		{
                                                                                    if(symbolTable->getLastFunc()->returnType.compare(string("VOID"))!=0)
																					{
																					    errorMismatch(yylineno);
																					    exit(0);
																					}
																					$$ = new statement();};
Statement : RETURN Exp SC  															
{
    const char* type = ((Exp*)$2)->type.c_str();
    //Check if function return type is same as expression type - report ERROR
    //if(symbolTable->getLastFunc()->returnType!=type)

    //if(symbolTable->getLastFunc()->returnType.compare("VOID")==0 || symbolTable->getLastFunc()->returnType.compare(string(type))!=0)
    if(symbolTable->getLastFunc()->returnType.compare("VOID")==0 || !symbolTable->isAssignLegal(symbolTable->getLastFunc()->returnType.c_str(),type))
    {
        errorMismatch(yylineno);
        exit(0);
    }
	
	    Exp* tmp4 = (Exp*)$2;

    bool cond = (((Exp*)tmp4)->rigister.compare((string("NA"))) == 0) &&
            (((Exp*)tmp4)->type.compare((string("BOOL"))) == 0);

    if(cond)
    {


        bpList * trueL = tmp4->listCol->true_list;
        bpList * falseL = tmp4->listCol->false_list;


        string tmp1;
        string tmp2;
        string tmp3;

        CodeBuffer::instance().emit("unreachable\n");
        string tmp = handleBool();

        tmp1 = returnFirstAppearance(tmp);
        tmp2 = returnSecondAppearance(tmp);
        tmp3 = returnThirdAppearance(tmp);

        tmp4->rigister = tmp1;

        CodeBuffer::instance().bpatch(*trueL, tmp2);
        CodeBuffer::instance().bpatch(*falseL, tmp3);


		finishFunctionScope(tmp4->info, tmp4->type, tmp4->rigister, symbolTable->getLastFunc()->returnType);
    }
	
    $$ = new statement();
};
Statement: IfRule %prec IF
{
	$$ = new statement();

    statements * tmp = (statements*)$1;
    statement * tmp2 = (statement*)$$;
    bpList * tmp_next = tmp->listCol->next_list;
    bpList * tmp_else = tmp->listCol->else_list;
    bpList * continue_list = tmp->listCol->continue_list;
    bpList * break_list = tmp->listCol->break_list;

    *(tmp2->listCol->next_list) = (CodeBuffer::instance().merge(*tmp_next,*tmp_else));
    (tmp2->listCol->continue_list) = continue_list;
    (tmp2->listCol->break_list) = break_list;
	
};


Statement : IfRule ELSE
{
statement * tmp = (statement*)$1;
bpList * else_list = tmp->listCol->else_list;
CodeBuffer::instance().bpatch( *else_list , CodeBuffer::instance().genLabel());
symbolTable->AddNewTable("IF");
}
Statement
{
symbolTable->pop();
$$ = new statement();
    symbolTable->pop();
    $$ = new statement();
    statement * tmp = (statement*)$$;
    bpList * uncondBranch = new bpList();
    *tmp->listCol->next_list = CodeBuffer::instance().merge(*((statement*)$4)->listCol->next_list ,*((statement*)$1)->listCol->next_list  );
    handleUBR(uncondBranch);
    *tmp->listCol->next_list = CodeBuffer::instance().merge(*((statement*)$4)->listCol->next_list ,*uncondBranch  );
    *tmp->listCol->continue_list = CodeBuffer::instance().merge(*((statement*)$4)->listCol->continue_list ,*((statement*)$1)->listCol->continue_list  );
    *tmp->listCol->break_list = CodeBuffer::instance().merge(*((statement*)$4)->listCol->break_list ,*((statement*)$1)->listCol->break_list  );



};
IfRule : IF LPAREN Exp RPAREN
{//open a block because of if statement

    string type = ((Exp*)$3)->type;

    if(type.compare("BOOL")!=0){
        errorMismatch(yylineno);
        exit(0);
    }
       Exp* tmp3 = (Exp*)$3;
        bpList * tl;
        bpList * fl;
        if(tmp3->rigister.compare("NA") != 0)
        {
            emitConditionalBranchSavedArg(tmp3->rigister, tl, fl);
            tmp3->listCol->true_list = tl;
            tmp3->listCol->false_list = fl;
        }
        CodeBuffer::instance().emit("unreachable\n");
        string lbl = CodeBuffer::instance().genLabel();
        CodeBuffer::instance().bpatch( *tmp3->listCol->true_list , lbl);

    symbolTable->AddNewTable("IF");
}
Statement
{
    //After Statement
    symbolTable->pop();
    $$ = new statement();
};

Statement : WHILE wMrkr LPAREN Exp RPAREN
                                                                                    {
                                                                                    const char* lbl = CodeBuffer::instance().genLabel().c_str();
                                                                                    string type = ((Exp*)$3)->type; //o
                                                                                     if(type.compare("BOOL")!=0)
                                                                                     {//o
                                                                                           errorMismatch(yylineno); //o
                                                                                           exit(0); //o
                                                                                     } //o

                                                                                     symbolTable->AddNewTable("WHILE"); //o
                                                                                     Exp * tmp1 = (Exp*)$4;
                                                                                     if(tmp1->rigister.compare("NA") == 0)
                                                                                     {
                                                                                         CodeBuffer::instance().emit("unreachable\n");
                                                                                         CodeBuffer::instance().bpatch( *tmp1->listCol->true_list , string(lbl));
                                                                                     }

                                                                                     else
                                                                                         {
                                                                                             bpList * trueList = new bpList();
                                                                                             bpList * falseList = new bpList();
                                                                                             emitConditionalBranchSavedArg(tmp1->rigister, trueList, falseList);
                                                                                             CodeBuffer::instance().bpatch( *trueList , string(lbl));
                                                                                             tmp1->listCol->false_list = falseList;
                                                                                         }

																					}

Statement 																			{
																					    statement * dollardollar = (statement*)$$;
                                                                                        Exp * dollar4 = (Exp*)$4;
                                                                                        symbolTable->pop();
                                                                                        $$ = new statement();
                                                                                        bpList * newList = new bpList();
                                                                                        handleUBR(newList);
                                                                                        statement * tmp7 = (statement*)$7;
                                                                                        *(tmp7->listCol->continue_list) = CodeBuffer::instance().merge( *tmp7->listCol->continue_list, *newList);
                                                                                        string info = $2->info;
                                                                                        bpList * llist = tmp7->listCol->continue_list;
                                                                                        CodeBuffer::instance().bpatch(*llist, info);
                                                                                        *dollardollar->listCol->next_list = CodeBuffer::instance().merge( *dollar4->listCol->false_list,  *tmp7->listCol->break_list);
																					};

wMrkr :
{
        const char* lbl2 = CodeBuffer::instance().genLabel().c_str();
        bpList * list = new bpList();
        handleUBR(list);
        CodeBuffer::instance().bpatch(*list, string(lbl2));
        $$ = new Node();
        $$->info = *(new string(lbl2));
}

Statement : BREAK SC  																{ if (!symbolTable->isContainedByScopeType("WHILE") && !symbolTable->isContainedByScopeType("SWITCH")){
																					errorUnexpectedBreak(yylineno);
																					exit(0);
																					}
																					$$ = new statement();};
Statement : CONTINUE SC 															{
                                                                                    if (!symbolTable->isContainedByScopeType("WHILE")) {
																					errorUnexpectedContinue(yylineno);
																					exit(0);
																					}
																					$$ = new statement();};
Statement : SWITCH LPAREN Exp RPAREN 												{ string type = ((Exp*)$3)->type;
    //printf("SWITCH variable is: %s\n", ((Exp*)$3)->info.c_str());
    if(!symbolTable->isVarExists(((Exp*)$3)->info.c_str())){
        errorUndef(yylineno, ((Exp*)$3)->info);
        exit(0);
    }
    symbolTable->AddNewTable("SWITCH");}
LBRACE 																				{//symbolTable->AddNewTable("SWITCH");
}
CaseList RBRACE																		{
//symbolTable->pop();
    symbolTable->pop();
    $$ = new statement();};


Call : ID LPAREN ExpList RPAREN
{
    //Check if function was defined.
    //Check if parameters are matching.
    vector<string> paramTypes;
    const char* funcName = ((Node*)$1)->info.c_str();
    EXPlist * paramsToFunc = (EXPlist*)$3;

    if(symbolTable->getFunction(funcName) == nullptr)
    {
       errorUndefFunc(yylineno, string(funcName));
       exit(0);
    }

    for(int i = 0; i<(symbolTable->getFunction(funcName)->paramList).size();i++)
    {
       paramTypes.push_back((symbolTable->getFunction(funcName)->paramList)[i].type);
    }

    if(paramsToFunc->vectorOfExp.size() != (symbolTable->getFunction(funcName))->paramList.size())
    {
       errorPrototypeMismatch(yylineno, string(funcName), paramTypes);
       exit(0);
    }

    for(int i = 0; i<(symbolTable->getFunction(funcName))->paramList.size(); i++)
    {
             string realFunctionParam = symbolTable->getFunction(funcName)->paramList[i].type;
             string calledFunctionParam = paramsToFunc->vectorOfExp[i].type;

             if(realFunctionParam.compare(calledFunctionParam) == 0 || (realFunctionParam.compare(string("INT"))==0 &&
             calledFunctionParam.compare(string("BYTE"))==0))
             {
                continue;
             }

                errorPrototypeMismatch(yylineno, string(funcName), paramTypes);
                exit (0);
    }

    $$ = new call(symbolTable->getFunction(funcName)->returnType.c_str(), symbolTable->getFunction(funcName)->funcName.c_str(), new EXPlist(*paramsToFunc));

};


Call : ID LPAREN RPAREN 														    {    //Check if function exists in DB
    																				//Check parameters match
    																				const char* funcName = $1->info.c_str();
    																				vector<formalDeclaration> paramList;
    																				funcDeclaration * newFunc = new funcDeclaration(funcName,paramList , " ");

                                                                                     vector<string> paramTypes;


                                                                                       funcDeclaration * f = symbolTable->getFunction(funcName);


                                                                                        if(symbolTable->getFunction(funcName) == nullptr)
                                                                                        {
                                                                                           errorUndefFunc(yylineno, string(funcName));
                                                                                           exit(0);
                                                                                        }

                                                                                         for(int i = 0; i<f->paramList.size();i++)
                                                                                          {
                                                                                           paramTypes.push_back(f->paramList[i].type);
                                                                                          }

    																				if(!symbolTable->isFuncExistsByName(*newFunc))
    																				{
    																				    errorUndefFunc(yylineno,((Node*)$1)->info);
    																				    exit(0);
																					}


																					if(f->paramList.size()!=0)
																					{
                                                                                           errorPrototypeMismatch(yylineno, string(funcName), paramTypes);
                                                                                           exit(0);
																					}


																					$$ = new call(symbolTable->getFunctionType(funcName), funcName);


                                                                                        call * tmp = (call*)$$;
                                                                                        Node* tmp2 = $1;
                                                                                        const char* rg1;
                                                                                        callFuncEmitHandler(rg1, tmp2->info.c_str(), symbolTable->getFunctionType(tmp2->info.c_str()));
                                                                                        tmp->rigister = rg1;

																					};
ExpList : Exp
{
  bpList * list = nullptr;
   Exp* tmp1 = (Exp*) $1;
   string to_seperate;
   string s1;
   string s2;
   string s3;
   if(tmp1->info.compare("BOOL")==0 && tmp1->rigister.compare("NA")==0)
   {
       handleUBR(list);
       to_seperate = handleBool();
       s1 = returnFirstAppearance(to_seperate);
       s2 = returnSecondAppearance(to_seperate);
       s3 = returnThirdAppearance(to_seperate);
       tmp1->rigister = s1;
       CodeBuffer::instance().bpatch(*tmp1->listCol->true_list, s2);
       CodeBuffer::instance().bpatch(*tmp1->listCol->false_list, s3);
       if(string(tmp1->bcklbl).compare("NA") != 0)
       {
           handleUBR(list);
           CodeBuffer::instance().bpatch(*list, (tmp1)->bcklbl);
       }
   }
   $$ = new EXPlist(tmp1);

   EXPlist * dollardollar = (EXPlist*)$$;
   dollardollar ->listCol->label_list = list;

};
ExpList : Exp COMMA ExpList
{
    string to_seperate;
    string s1;
    string s2;
    string s3;
    EXPlist * tmp3 = (EXPlist*) $3;
    Exp * tmp1 = (Exp*) $1;
    bpList * tmp3_list = nullptr;
    bpList * ttmp_list = nullptr;
    tmp3_list = tmp3->listCol->label_list;
    if(tmp1->type.compare("BOOL") == 0 && tmp1->rigister.compare("NA") == 0)
    {
        if(tmp3_list->size() == 0)
        {
            handleUBR(tmp3_list);
        }
        to_seperate = handleBool();
        s1 = returnFirstAppearance(to_seperate);
        s2 = returnSecondAppearance(to_seperate);
        s3 = returnThirdAppearance(to_seperate);
        tmp1->rigister = s1;
        CodeBuffer::instance().bpatch(*tmp3->listCol->true_list, s2);
        CodeBuffer::instance().bpatch(*tmp3->listCol->false_list, s3);

        if(tmp3->listCol->label_list->size() > 0)
        {
            handleUBR(ttmp_list);
            CodeBuffer::instance().bpatch(*ttmp_list, tmp1->bcklbl);
        }

    }

    $$ = new EXPlist(tmp1,tmp3);
    tmp3->listCol->label_list = tmp3_list;

};
Type : INT  																 		{//printf("Type : INT \n");
                                                                                         $$ = new Type("NA","INT");
                                                                                    };
Type : BYTE  																 		{//printf("Type : byte \n");
                                                                                                        $$ = new Type("NA","BYTE");
                                                                                    };
Type : BOOL 																        {//printf("Type : bool \n");
                                                                                                    $$ = new Type("NA","BOOL");
                                                                                    };
Exp : LPAREN Exp RPAREN 														    {
                                                                                    $$ = new Exp("NA", ((Exp*)$2)->type.c_str());

                                                                                    };
Exp : Exp BINOPMUL Exp
{
string leftType = ((Exp*)$1)->type;
    string rightType = ((Exp*)$3)->type;
    if((leftType.compare("INT")!=0 && leftType.compare("BYTE")!=0) || (rightType.compare("INT")!=0 && rightType.compare("BYTE")!=0)){
        errorMismatch(yylineno);
        exit(0);
    }
    else{
        string resultType;
        if(leftType.compare("INT")==0 || rightType.compare("INT")==0)
        {
            resultType = "INT";
        }
        else
        {
            resultType = "BYTE";
        }
        $$ = new Exp("NA", resultType.c_str());


    const char * opArr[2];
    Exp * tmp1 = (Exp*) $1;
    Exp * tmp3 = (Exp*) $3;
    Node* tmp2 = (Node*) $2;
    Exp* tmpp = (Exp*) $$;
    const char* rg;

    if(tmp1->rigister.compare("NA") == 0)
    {
        opArr[0] = tmp1->rigister.c_str();
    }
    else
    {
        opArr[0] = tmp1->info.c_str();
    }

    if(tmp3->rigister.compare("NA") == 0)
    {
        opArr[1] = tmp3->rigister.c_str();
    }
    else
    {
        opArr[1] = tmp3->info.c_str();
    }

    emitBinary(tmp2->info.c_str(),opArr[0], opArr[1], tmp1->type.c_str(), tmp3->type.c_str(), &rg);

    tmpp->rigister = rg;

    }};
Exp : Exp BINOPPLUS Exp
{string leftType = ((Exp*)$1)->type;
    string rightType = ((Exp*)$3)->type;
    if((leftType.compare("INT")!=0 && leftType.compare("BYTE")!=0) || (rightType.compare("INT")!=0 && rightType.compare("BYTE")!=0)){
        errorMismatch(yylineno);
        exit(0);
    }
    else{
        string resultType;
       if(leftType.compare("INT")==0 || rightType.compare("INT")==0){
            resultType = "INT";
       }
        else{
            resultType = "BYTE";
        }
        $$ = new Exp("NA", resultType.c_str());

            const char * opArr[2];
            Exp * tmp1 = (Exp*) $1;
            Exp * tmp3 = (Exp*) $3;
            Node* tmp2 = (Node*) $2;
            Exp* tmpp = (Exp*) $$;
            const char* rg;

            if(tmp1->rigister.compare("NA") == 0)
            {
                opArr[0] = tmp1->rigister.c_str();
            }
            else
            {
                opArr[0] = tmp1->info.c_str();
            }

            if(tmp3->rigister.compare("NA") == 0)
            {
                opArr[1] = tmp3->rigister.c_str();
            }
            else
            {
                opArr[1] = tmp3->info.c_str();
            }

            emitBinary(tmp2->info.c_str(),opArr[0], opArr[1], tmp1->type.c_str(), tmp3->type.c_str(), &rg);

            tmpp->rigister = rg;

    }
};
Exp : ID  																            {
if(!symbolTable->isVarExists(((Node*)$1)->info.c_str()))
    {
        errorUndef(yylineno,((Node*)$1)->info);
        exit(0);
    }

    string info = ((Node*)$1)->info;

    Symbol symbol = symbolTable->searchSymbolByName(info.c_str());

    string type = symbol.Type;
    //printf("type is: %s\n", type.c_str());
    $$ = new Exp(info.c_str(), type.c_str());
};
Exp : Call 																            {$$ = new Exp("NA", ((call*)$1)->type.c_str());};
Exp : NUM  																            {$$ = new Exp("NA", "INT");};
Exp : NUM B   																		{  int maxVal = 255;
    if(stoi(((Node*)$1)->info) > maxVal)
    {
        errorByteTooLarge(yylineno,((Node*)$1)->info);
        exit(0);
    }
    $$ = new Exp("NA", "BYTE");
    };
Exp : STRING  																		{$$ = new Exp(((Exp*)$1)->info.c_str(), "STRING");};
Exp : TRUE    																		{$$ = new Exp(((Exp*)$1)->info.c_str(), "BOOL");};
Exp : FALSE   																		{$$ = new Exp(((Exp*)$1)->info.c_str(), "BOOL");};
Exp : NOT Exp 																		{
    Exp* tmp = (Exp*)$2;
    if(tmp->type.compare(*(new string("BOOL")))==0)
    {
        $$ = new Exp("NA","BOOL");
    }
    else
    {
        errorMismatch(yylineno);
        exit(0);
    }

         string * reg = new string();
         Exp* tmp2 = (Exp*) $2;
         Exp * tmp0 = (Exp*) $$;
         if(tmp2->rigister.compare("NA") == 0)
         {
             ESbool(tmp2->rigister.c_str(),reg);
             tmp0->rigister = *reg;
         }
         tmp0->listCol->true_list = tmp2->listCol->false_list;
         tmp0->listCol->false_list = tmp2->listCol->true_list;


    };
Exp : Exp AND Exp  																    {
string leftType = ((Exp*)$1)->type;
    string rightType = ((Exp*)$3)->type;
    if(leftType.compare("BOOL")!=0 || rightType.compare("BOOL")!=0){
        errorMismatch(yylineno);
        exit(0);
    }
    $$ = new Exp("NA","BOOL");};
Exp : Exp OR Exp   																    {
string leftType = ((Exp*)$1)->type;
    string rightType = ((Exp*)$3)->type;
    if(leftType.compare("BOOL")!=0 || rightType.compare("BOOL")!=0){
        errorMismatch(yylineno);
        exit(0);
    }
    $$ = new Exp("NA","BOOL");};
Exp : Exp RELOPREL Exp 																{string leftType = ((Exp*)$1)->type;
    string rightType = ((Exp*)$3)->type;
    if((leftType.compare("INT")!=0 && leftType.compare("BYTE")!=0) || (rightType.compare("INT")!=0 && rightType.compare("BYTE")!=0)){
        errorMismatch(yylineno);
        exit(0);
    }
    $$ = new Exp("NA","BOOL");

        bpList * list;
        const char* op1;
        const char* op2;
        Exp * tmp1 = (Exp*) $1;
        Exp * tmp3 = (Exp*) $3;
        Node * tmp2 = (Node*) $2;
        Exp * tmp = (Exp*) $$;

        if(tmp1->rigister.compare("NA") == 0)
        {
            op1 = tmp1->rigister.c_str();
        }
        if(tmp1->rigister.compare("NA") != 0)
        {
            op1 = tmp1->info.c_str();
        }

        if(tmp3->rigister.compare("NA") == 0)
        {
            op2 = tmp3->rigister.c_str();
        }
        if(tmp3->rigister.compare("NA") != 0)
        {
            op2 = tmp3->info.c_str();
        }

        emitRelopHandler(tmp2->info.c_str(), op1, op2, tmp1->type.c_str(), tmp3->type.c_str(), &list);

        *(tmp->listCol->true_list) = CodeBuffer::instance().makelist((*list)[0]);
        *(tmp->listCol->true_list) = CodeBuffer::instance().makelist((*list)[1]);
        tmp->bcklbl = CodeBuffer::instance().genLabel().data();


    };
Exp : Exp RELOPEQ Exp 																{string leftType = ((Exp*)$1)->type;
    string rightType = ((Exp*)$3)->type;
    if((leftType.compare("INT")!=0 && leftType.compare("BYTE")!=0) || (rightType.compare("INT")!=0 && rightType.compare("BYTE")!=0)){
        errorMismatch(yylineno);
        exit(0);
    }

    $$ = new Exp("NA","BOOL");

            bpList * list;
            const char* op1;
            const char* op2;
            Exp * tmp1 = (Exp*) $1;
            Exp * tmp3 = (Exp*) $3;
            Node * tmp2 = (Node*) $2;
            Exp * tmp = (Exp*) $$;

            if(tmp1->rigister.compare("NA") == 0)
            {
                op1 = tmp1->rigister.c_str();
            }
            if(tmp1->rigister.compare("NA") != 0)
            {
                op1 = tmp1->info.c_str();
            }

            if(tmp3->rigister.compare("NA") == 0)
            {
                op2 = tmp3->rigister.c_str();
            }
            if(tmp3->rigister.compare("NA") != 0)
            {
                op2 = tmp3->info.c_str();
            }

            emitRelopHandler(tmp2->info.c_str(), op1, op2, tmp1->type.c_str(), tmp3->type.c_str(), &list);

            *(tmp->listCol->true_list) = CodeBuffer::instance().makelist((*list)[0]);
            *(tmp->listCol->true_list) = CodeBuffer::instance().makelist((*list)[1]);
            tmp->bcklbl = CodeBuffer::instance().genLabel().data();

    };
CaseList : CaseDecl CaseList														{$$ = new CaseList();};
 CaseList : CaseDecl																	{$$ = new CaseList();};
 CaseList : DEFAULT COLON Statements													{$$ = new CaseList();};
 CaseDecl : CASE NUM COLON Statements												{$$ = new CaseList();};


%%


int main (){
    yyparse();
    if(!symbolTable->isMainExist())
    {
        errorMainMissing();
        exit(0);
    }
    symbolTable->printFuncs();

};

int yyerror(const char * message){
    errorSyn(yylineno);
    exit(0);
}








